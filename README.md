# Computer club management system
Simple Computer club management system made as test task for Yadro

Для сборки проекта достаточно обычных инструментов (например, cmake)

Случаи, про которые не было четко написано в ТЗ, и как я их разрешил:

1. Если мне приходит некорректный номер стола в событии ID 2, то я вывожу эту строку и останавливаюсь
2. Если события происходят в нерабочее время, они все равно выводятся между временем начала работы и временем конца, как это указано в ТЗ
3. Если клиент пересаживается с одного стола за другой, то оплата считается независимо. То есть 2.5 часа за столом 1 и 1.5 часа за столом 2 будут обсчитаны как 3 часа оплаты + 2 часа оплаты, а не как-либо иначе
4. Если клиент просидел за столом 0 минут, я не требую с него оплаты
5. Несмотря на то, что в ТЗ это явно не оговорено, я вывожу ID 13 NotOpenYet на все события, происходящие в нерабочие часы. ТЗ предполагает это только для событий ID 1
6. В ТЗ не были указаны ограничения на целые числа (кроме положительности в некоторых случаях). Я решил пользоваться `int` и специально не учитывать переполнения. Думаю, об стоит задумываться, когда известны точные ограничения. Если позволять `MAX_INT` для цены и количества клиентов, то даже 64-битного типа данных не хватит и надо использовать 128-битный. Учитывая постановку задачи "компьютерный клуб" (на вряд ли наш клуб так популярен, чтобы там были миллиарды пользователей), я готов верить, что `int` должно быть достаточно и это целесообразно. Если же это не так, то поменять в некоторых местах типы на более широкие не является затруднительным

Отдельные замечания про работу с очередями (к столам):
1. В ТЗ не сказано, что делать, если в очередь пытается записаться клиент, не находящийся в клубе. Я вывожу ID 13 ClientUnknown
2. В ТЗ не указано, как поступать, если в очередь пытается снова записаться тот, кто в ней уже состоит, или тот, кто сейчас уже сидит за столом. Я в таких случаях специально делаю ничего. То есть даже событие ID 11 в этой ситуации генерироваться не будет, если очередь заполнена. В моем понимании, некорректность такого поведения превалирует над формальными критериями работы очереди
3. В ТЗ не прописано, что делать, если клиент, находящийся в очереди, уходит их клуба. Я решил в таком случае удалять его из очереди

Замечание об эффективности удаления из очереди в п.3. Когда клиент выходит из клуба, я явно проверяю для него, находится ли он в очереди и если да, явно удаляю. В итоге это требует линейного прохода по очереди, что кажется чем-то плохим. Однако это важно делать, потому что иначе очередь забивается ушедшими людьми и теряется представление о реально величине очереди.

Конечно, для ускорения можно было бы использовать, например, `std::set` или `std::unordered_set`, однако тут возникает другая проблема. Наш клиент может уйти из клуба, затем подождать сколько-то и вернуться, а затем снова записаться в очередь. И тогда он будет в ней находиться дважды, при этом по праву существовать в сете. И тогда будет нарушаться инвариант, который мне кажется справедливым для подобной очереди: человек должен терять место в очереди, как только ушел из клуба.